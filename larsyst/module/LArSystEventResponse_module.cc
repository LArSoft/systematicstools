////////////////////////////////////////////////////////////////////////
// Class:       lareventsyst
// Plugin Type: producer (art v2_10_03)
// File:        lareventsyst_module.cc
//
// Generated at Fri Apr 13 12:16:24 2018 by Luke Pickering using cetskelgen
// from cetlib version v3_02_00.
////////////////////////////////////////////////////////////////////////

#include "larsyst/interface/ISystProvider_tool.hh"
#include "larsyst/utility/append_event_response.hh"
#include "larsyst/utility/configure_syst_providers.hh"
#include "larsyst/utility/md5.hh"
#include "larsyst/utility/scrub_unity_responses.hh"

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/make_tool.h"

#include "canvas/Utilities/InputTag.h"

#include "fhiclcpp/ParameterSet.h"
#include "fhiclcpp/types/Sequence.h"
#include "fhiclcpp/types/Table.h"

#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

class lareventsyst;

class lareventsyst : public art::EDProducer {
public:
  explicit lareventsyst(fhicl::ParameterSet const &p);
  // The compiler-generated destructor is fine for non-base
  // classes without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  lareventsyst(lareventsyst const &) = delete;
  lareventsyst(lareventsyst &&) = delete;
  lareventsyst &operator=(lareventsyst const &) = delete;
  lareventsyst &operator=(lareventsyst &&) = delete;

  // Required functions.
  void produce(art::Event &e) override;

private:
  larsyst::provider_map_t syst_providers;

  std::string sp_config_hash;
};

lareventsyst::lareventsyst(fhicl::ParameterSet const &p)
    : syst_providers{}, sp_config_hash("") {

  if (!p.has_key("generated_systematic_provider_configuration")) {
    std::cout << "[ERROR]: Could not find producer key: "
                 "\"generated_systematic_provider_configuration\". This should "
                 "contain a "
                 "list of configured systematic providers generated by "
                 "GenerateSystProviderConfig."
              << std::endl;
    throw;
  }

  fhicl::ParameterSet syst_provider_config =
      p.get<fhicl::ParameterSet>("generated_systematic_provider_configuration");
  sp_config_hash = md5(syst_provider_config.to_compact_string());

  std::cout << "[INFO]: md5 of systematic provider configuration: "
            << sp_config_hash << std::endl;

  syst_providers =
      larsyst::load_syst_provider_configuration(syst_provider_config);

  produces<larsyst::EventResponse>(sp_config_hash);
}

void lareventsyst::produce(art::Event &e) {
  std::unique_ptr<larsyst::EventResponse> er =
      std::make_unique<larsyst::EventResponse>();
  bool first = true;
  std::cout
      << "[INFO]: Starting to generate syst provider responses for event: "
      << e.event() << std::endl;
  for (auto &sp : syst_providers) {
    std::unique_ptr<larsyst::EventResponse> syst_resp =
        sp.second->GetEventResponse(e);
    if (!syst_resp) {
      std::cout << "[ERROR]: Got null syst response from provider "
                << sp.second->GetFullyQualifiedName() << std::endl;
    }
    if (first) {
      er = std::move(syst_resp);
      std::cout << "\tAdded first syst provider response." << std::endl;
      first = false;
    } else {
      append_event_response(er, std::move(syst_resp));
      std::cout << "\tAppended syst provider response." << std::endl;
    }
  }

  if (!er) {
    std::cout << "[ERROR]: Null event response pointer." << std::endl;
    throw;
  }

  larsyst::scrub_unity_responses(er);
  for (size_t ctr = 0; ctr < er->responses.size(); ++ctr) {
    std::cout << "[INFO]: For (event:unit) = (" << e.event() << ":" << ctr
              << ") writing " << er->responses[ctr].size()
              << " responses: " << std::endl;
    for (auto irmap : er->responses[ctr]) {
      std::cout << "\t ParamId: " << irmap.first << " with "
                << irmap.second.size() << " responses." << std::endl;
    }
  }

  std::cout << "[INFO]: Built response: " << larsyst::to_str(*er) << std::endl;

  e.put(std::move(er), sp_config_hash);
}

DEFINE_ART_MODULE(lareventsyst)
