////////////////////////////////////////////////////////////////////////
// Class:       SystToolsEventResponse
// Plugin Type: producer (art v2_10_03)
// File:        SystToolsEventResponse_module.cc
//
// Generated at Fri Apr 13 12:16:24 2018 by Luke Pickering using cetskelgen
// from cetlib version v3_02_00.
////////////////////////////////////////////////////////////////////////

#include "systematicstools/interface/ISystProviderTool.hh"

#include "systematicstools/utility/ParameterAndProviderConfigurationUtility.hh"
#include "systematicstools/utility/exceptions.hh"
#include "systematicstools/utility/md5.hh"

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/make_tool.h"

#include "canvas/Utilities/InputTag.h"

#include "fhiclcpp/ParameterSet.h"
#include "fhiclcpp/types/Sequence.h"
#include "fhiclcpp/types/Table.h"

#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

class SystToolsEventResponse;

class SystToolsEventResponse : public art::EDProducer {

  NEW_SYSTTOOLS_EXCEPT(no_systprovider_key);
  NEW_SYSTTOOLS_EXCEPT(nullptr_event_response);

public:
  explicit SystToolsEventResponse(fhicl::ParameterSet const &p);
  // The compiler-generated destructor is fine for non-base
  // classes without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SystToolsEventResponse(SystToolsEventResponse const &) = delete;
  SystToolsEventResponse(SystToolsEventResponse &&) = delete;
  SystToolsEventResponse &operator=(SystToolsEventResponse const &) = delete;
  SystToolsEventResponse &operator=(SystToolsEventResponse &&) = delete;

  // Required functions.
  void produce(art::Event &e) override;

private:
  systtools::provider_list_t syst_providers;

  std::string sp_config_hash;
};

SystToolsEventResponse::SystToolsEventResponse(fhicl::ParameterSet const &p)
    : syst_providers{}, sp_config_hash("") {

  if (!p.has_key("generated_systematic_provider_configuration")) {
    throw no_systprovider_key()
        << "[ERROR]: Could not find producer key: "
           "\"generated_systematic_provider_configuration\". This should "
           "contain a list of configured systematic providers generated by "
           "GenerateSystProviderConfig.";
  }

  fhicl::ParameterSet syst_provider_config =
      p.get<fhicl::ParameterSet>("generated_systematic_provider_configuration");
  sp_config_hash = md5(syst_provider_config.to_compact_string());

  std::cout << "[INFO]: md5 of systematic provider configuration: "
            << sp_config_hash << std::endl;

  syst_providers = systtools::ConfigureISystProvidersFromParameterHeaders(
      syst_provider_config);

  produces<systtools::EventResponse>(sp_config_hash);
}

void SystToolsEventResponse::produce(art::Event &e) {
  std::unique_ptr<systtools::EventResponse> er =
      std::make_unique<systtools::EventResponse>();

  for (auto &sp : syst_providers) {
    std::unique_ptr<systtools::EventResponse> syst_resp =
        sp->GetEventResponse(e);
    if (!syst_resp) {
      throw nullptr_event_response()
          << "[ERROR]: Got nullptr systtools::EventResponse from provider "
          << sp->GetFullyQualifiedName();
    }
    systtools::ExtendEventResponse(er, std::move(syst_resp));
  }

  systtools::ScrubUnityEventResponses(er);

  e.put(std::move(er), sp_config_hash);
}

DEFINE_ART_MODULE(SystToolsEventResponse)
